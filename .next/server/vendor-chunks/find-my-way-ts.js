"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/find-my-way-ts";
exports.ids = ["vendor-chunks/find-my-way-ts"];
exports.modules = {

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js":
/*!*************************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/QueryString.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * @since 1.0.0\n */\n// Taken from https://github.com/anonrig/fast-querystring under MIT License\nconst plusRegex = /\\+/g;\nconst Empty = function () {};\nEmpty.prototype = /*#__PURE__*/Object.create(null);\n/**\n * @category parsing\n * @since 1.0.0\n */\nfunction parse(input) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty();\n  if (typeof input !== \"string\") {\n    return result;\n  }\n  const inputLength = input.length;\n  let key = \"\";\n  let value = \"\";\n  let startingIndex = -1;\n  let equalityIndex = -1;\n  let shouldDecodeKey = false;\n  let shouldDecodeValue = false;\n  let keyHasPlus = false;\n  let valueHasPlus = false;\n  let hasBothKeyValuePair = false;\n  let c = 0;\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38;\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex;\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i;\n      }\n      key = input.slice(startingIndex + 1, equalityIndex);\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \");\n        }\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          key = decodeURIComponent(key) || key;\n        }\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i);\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \");\n          }\n          if (shouldDecodeValue) {\n            value = decodeURIComponent(value) || value;\n          }\n        }\n        const currentValue = result[key];\n        if (currentValue === undefined) {\n          result[key] = value;\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value);\n          } else {\n            result[key] = [currentValue, value];\n          }\n        }\n      }\n      // Reset reading key value pairs\n      value = \"\";\n      startingIndex = i;\n      equalityIndex = i;\n      shouldDecodeKey = false;\n      shouldDecodeValue = false;\n      keyHasPlus = false;\n      valueHasPlus = false;\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i;\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true;\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true;\n      } else {\n        keyHasPlus = true;\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true;\n      } else {\n        shouldDecodeKey = true;\n      }\n    }\n  }\n  return result;\n}\nfunction getAsPrimitive(value) {\n  const type = typeof value;\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value);\n  } else if (type === \"bigint\" || type === \"boolean\") {\n    return \"\" + value;\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value);\n  }\n  return \"\";\n}\n/**\n * @category encoding\n * @since 1.0.0\n */\nfunction stringify(input) {\n  let result = \"\";\n  if (input === null || typeof input !== \"object\") {\n    return result;\n  }\n  const separator = \"&\";\n  const keys = Object.keys(input);\n  const keyLength = keys.length;\n  let valueLength = 0;\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i];\n    const value = input[key];\n    const encodedKey = encodeString(key) + \"=\";\n    if (i) {\n      result += separator;\n    }\n    if (Array.isArray(value)) {\n      valueLength = value.length;\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator;\n        }\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey;\n        result += getAsPrimitive(value[j]);\n      }\n    } else {\n      result += encodedKey;\n      result += getAsPrimitive(value);\n    }\n  }\n  return result;\n}\n// -----------------------------------------------------------------------------\n// This has been taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\nconst hexTable = /*#__PURE__*/Array.from({\n  length: 256\n}, (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase());\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// biome-ignore format: the array should not be formatted\nconst noEscape = /*#__PURE__*/new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 16 - 31\n0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0,\n// 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n// 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,\n// 80 - 95\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0 // 112 - 127\n]);\nfunction encodeString(str) {\n  const len = str.length;\n  if (len === 0) return \"\";\n  let out = \"\";\n  let lastPos = 0;\n  let i = 0;\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i);\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i);\n        lastPos = i + 1;\n        out += hexTable[c];\n      }\n      if (++i === len) break outer;\n      c = str.charCodeAt(i);\n    }\n    if (lastPos < i) out += str.slice(lastPos, i);\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1;\n      out += hexTable[0xc0 | c >> 6] + hexTable[0x80 | c & 0x3f];\n      continue;\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1;\n      out += hexTable[0xe0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];\n      continue;\n    }\n    // Surrogate pair\n    ++i;\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\");\n    }\n    const c2 = str.charCodeAt(i) & 0x3ff;\n    lastPos = i + 1;\n    c = 0x10000 + ((c & 0x3ff) << 10 | c2);\n    out += hexTable[0xf0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3f] + hexTable[0x80 | c >> 6 & 0x3f] + hexTable[0x80 | c & 0x3f];\n  }\n  if (lastPos === 0) return str;\n  if (lastPos < len) return out + str.slice(lastPos);\n  return out;\n}\n//# sourceMappingURL=QueryString.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vUXVlcnlTdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFx0ZW1wXFxZb3VUdWJlXFxub2RlX21vZHVsZXNcXGZpbmQtbXktd2F5LXRzXFxkaXN0XFxlc21cXFF1ZXJ5U3RyaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKi9cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Fub25yaWcvZmFzdC1xdWVyeXN0cmluZyB1bmRlciBNSVQgTGljZW5zZVxuY29uc3QgcGx1c1JlZ2V4ID0gL1xcKy9nO1xuY29uc3QgRW1wdHkgPSBmdW5jdGlvbiAoKSB7fTtcbkVtcHR5LnByb3RvdHlwZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG4gKiBAY2F0ZWdvcnkgcGFyc2luZ1xuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAvLyBPcHRpbWl6YXRpb246IFVzZSBuZXcgRW1wdHkoKSBpbnN0ZWFkIG9mIE9iamVjdC5jcmVhdGUobnVsbCkgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIHY4IGhhcyBhIGJldHRlciBvcHRpbWl6YXRpb24gZm9yIGluaXRpYWxpemluZyBmdW5jdGlvbnMgY29tcGFyZWQgdG8gT2JqZWN0XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgbGV0IGtleSA9IFwiXCI7XG4gIGxldCB2YWx1ZSA9IFwiXCI7XG4gIGxldCBzdGFydGluZ0luZGV4ID0gLTE7XG4gIGxldCBlcXVhbGl0eUluZGV4ID0gLTE7XG4gIGxldCBzaG91bGREZWNvZGVLZXkgPSBmYWxzZTtcbiAgbGV0IHNob3VsZERlY29kZVZhbHVlID0gZmFsc2U7XG4gIGxldCBrZXlIYXNQbHVzID0gZmFsc2U7XG4gIGxldCB2YWx1ZUhhc1BsdXMgPSBmYWxzZTtcbiAgbGV0IGhhc0JvdGhLZXlWYWx1ZVBhaXIgPSBmYWxzZTtcbiAgbGV0IGMgPSAwO1xuICAvLyBIYXZlIGEgYm91bmRhcnkgb2YgaW5wdXQubGVuZ3RoICsgMSB0byBhY2Nlc3MgbGFzdCBwYWlyIGluc2lkZSB0aGUgbG9vcC5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dExlbmd0aCArIDE7IGkrKykge1xuICAgIGMgPSBpICE9PSBpbnB1dExlbmd0aCA/IGlucHV0LmNoYXJDb2RlQXQoaSkgOiAzODtcbiAgICAvLyBIYW5kbGUgJyYnIGFuZCBlbmQgb2YgbGluZSB0byBwYXNzIHRoZSBjdXJyZW50IHZhbHVlcyB0byByZXN1bHRcbiAgICBpZiAoYyA9PT0gMzgpIHtcbiAgICAgIGhhc0JvdGhLZXlWYWx1ZVBhaXIgPSBlcXVhbGl0eUluZGV4ID4gc3RhcnRpbmdJbmRleDtcbiAgICAgIC8vIE9wdGltaXphdGlvbjogUmV1c2UgZXF1YWxpdHkgaW5kZXggdG8gc3RvcmUgdGhlIGVuZCBvZiBrZXlcbiAgICAgIGlmICghaGFzQm90aEtleVZhbHVlUGFpcikge1xuICAgICAgICBlcXVhbGl0eUluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGtleSA9IGlucHV0LnNsaWNlKHN0YXJ0aW5nSW5kZXggKyAxLCBlcXVhbGl0eUluZGV4KTtcbiAgICAgIC8vIEFkZCBrZXkvdmFsdWUgcGFpciBvbmx5IGlmIHRoZSByYW5nZSBzaXplIGlzIGdyZWF0ZXIgdGhhbiAxOyBhLmsuYS4gY29udGFpbnMgYXQgbGVhc3QgXCI9XCJcbiAgICAgIGlmIChoYXNCb3RoS2V5VmFsdWVQYWlyIHx8IGtleS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogUmVwbGFjZSAnKycgd2l0aCBzcGFjZVxuICAgICAgICBpZiAoa2V5SGFzUGx1cykge1xuICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKHBsdXNSZWdleCwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9wdGltaXphdGlvbjogRG8gbm90IGRlY29kZSBpZiBpdCdzIG5vdCBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChzaG91bGREZWNvZGVLZXkpIHtcbiAgICAgICAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KSB8fCBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0JvdGhLZXlWYWx1ZVBhaXIpIHtcbiAgICAgICAgICB2YWx1ZSA9IGlucHV0LnNsaWNlKGVxdWFsaXR5SW5kZXggKyAxLCBpKTtcbiAgICAgICAgICBpZiAodmFsdWVIYXNQbHVzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocGx1c1JlZ2V4LCBcIiBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaG91bGREZWNvZGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIHx8IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSByZXN1bHRba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPcHRpbWl6YXRpb246IHZhbHVlLnBvcCBpcyBmYXN0ZXIgdGhhbiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUucG9wKSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gW2N1cnJlbnRWYWx1ZSwgdmFsdWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVzZXQgcmVhZGluZyBrZXkgdmFsdWUgcGFpcnNcbiAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIHN0YXJ0aW5nSW5kZXggPSBpO1xuICAgICAgZXF1YWxpdHlJbmRleCA9IGk7XG4gICAgICBzaG91bGREZWNvZGVLZXkgPSBmYWxzZTtcbiAgICAgIHNob3VsZERlY29kZVZhbHVlID0gZmFsc2U7XG4gICAgICBrZXlIYXNQbHVzID0gZmFsc2U7XG4gICAgICB2YWx1ZUhhc1BsdXMgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgJz0nXG4gICAgZWxzZSBpZiAoYyA9PT0gNjEpIHtcbiAgICAgIGlmIChlcXVhbGl0eUluZGV4IDw9IHN0YXJ0aW5nSW5kZXgpIHtcbiAgICAgICAgZXF1YWxpdHlJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICAvLyBJZiAnPScgY2hhcmFjdGVyIG9jY3VycyBhZ2Fpbiwgd2Ugc2hvdWxkIGRlY29kZSB0aGUgaW5wdXQuXG4gICAgICBlbHNlIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlVmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayAnKycsIGFuZCByZW1lbWJlciB0byByZXBsYWNlIGl0IHdpdGggZW1wdHkgc3BhY2UuXG4gICAgZWxzZSBpZiAoYyA9PT0gNDMpIHtcbiAgICAgIGlmIChlcXVhbGl0eUluZGV4ID4gc3RhcnRpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZUhhc1BsdXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5SGFzUGx1cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrICclJyBjaGFyYWN0ZXIgZm9yIGVuY29kaW5nXG4gICAgZWxzZSBpZiAoYyA9PT0gMzcpIHtcbiAgICAgIGlmIChlcXVhbGl0eUluZGV4ID4gc3RhcnRpbmdJbmRleCkge1xuICAgICAgICBzaG91bGREZWNvZGVWYWx1ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG91bGREZWNvZGVLZXkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0QXNQcmltaXRpdmUodmFsdWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyBMZW5ndGggY2hlY2sgaXMgaGFuZGxlZCBpbnNpZGUgZW5jb2RlU3RyaW5nIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGVuY29kZVN0cmluZyh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMWUyMSA/IFwiXCIgKyB2YWx1ZSA6IGVuY29kZVN0cmluZyhcIlwiICsgdmFsdWUpO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuLyoqXG4gKiBAY2F0ZWdvcnkgZW5jb2RpbmdcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KGlucHV0KSB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBpZiAoaW5wdXQgPT09IG51bGwgfHwgdHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBzZXBhcmF0b3IgPSBcIiZcIjtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGlucHV0KTtcbiAgY29uc3Qga2V5TGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGxldCB2YWx1ZUxlbmd0aCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5TGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbHVlID0gaW5wdXRba2V5XTtcbiAgICBjb25zdCBlbmNvZGVkS2V5ID0gZW5jb2RlU3RyaW5nKGtleSkgKyBcIj1cIjtcbiAgICBpZiAoaSkge1xuICAgICAgcmVzdWx0ICs9IHNlcGFyYXRvcjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaikge1xuICAgICAgICAgIHJlc3VsdCArPSBzZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3B0aW1pemF0aW9uOiBEaXZpZGluZyBpbnRvIG11bHRpcGxlIGxpbmVzIGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgLy8gU2luY2UgdjggZG9lcyBub3QgbmVlZCB0byBjYXJlIGFib3V0IHRoZSAnKycgY2hhcmFjdGVyIGlmIGl0IHdhcyBvbmUtbGluZXIuXG4gICAgICAgIHJlc3VsdCArPSBlbmNvZGVkS2V5O1xuICAgICAgICByZXN1bHQgKz0gZ2V0QXNQcmltaXRpdmUodmFsdWVbal0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gZW5jb2RlZEtleTtcbiAgICAgIHJlc3VsdCArPSBnZXRBc1ByaW1pdGl2ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhpcyBoYXMgYmVlbiB0YWtlbiBmcm9tIE5vZGUuanMgcHJvamVjdC5cbi8vIEZ1bGwgaW1wbGVtZW50YXRpb24gY2FuIGJlIGZvdW5kIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFpbi9saWIvaW50ZXJuYWwvcXVlcnlzdHJpbmcuanNcbmNvbnN0IGhleFRhYmxlID0gLyojX19QVVJFX18qL0FycmF5LmZyb20oe1xuICBsZW5ndGg6IDI1NlxufSwgKF8sIGkpID0+IFwiJVwiICsgKChpIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgaS50b1N0cmluZygxNikpLnRvVXBwZXJDYXNlKCkpO1xuLy8gVGhlc2UgY2hhcmFjdGVycyBkbyBub3QgbmVlZCBlc2NhcGluZyB3aGVuIGdlbmVyYXRpbmcgcXVlcnkgc3RyaW5nczpcbi8vICEgLSAuIF8gflxuLy8gJyAoICkgKlxuLy8gZGlnaXRzXG4vLyBhbHBoYSAodXBwZXJjYXNlKVxuLy8gYWxwaGEgKGxvd2VyY2FzZSlcbi8vIGJpb21lLWlnbm9yZSBmb3JtYXQ6IHRoZSBhcnJheSBzaG91bGQgbm90IGJlIGZvcm1hdHRlZFxuY29uc3Qgbm9Fc2NhcGUgPSAvKiNfX1BVUkVfXyovbmV3IEludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbi8vIDAgLSAxNVxuMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbi8vIDE2IC0gMzFcbjAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDEsIDAsXG4vLyAzMiAtIDQ3XG4xLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAwLCAwLCAwLFxuLy8gNDggLSA2M1xuMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbi8vIDY0IC0gNzlcbjEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDEsXG4vLyA4MCAtIDk1XG4wLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuLy8gOTYgLSAxMTFcbjEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dKTtcbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIFwiXCI7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBsZXQgbGFzdFBvcyA9IDA7XG4gIGxldCBpID0gMDtcbiAgb3V0ZXI6IGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIC8vIEFTQ0lJXG4gICAgd2hpbGUgKGMgPCAweDgwKSB7XG4gICAgICBpZiAobm9Fc2NhcGVbY10gIT09IDEpIHtcbiAgICAgICAgaWYgKGxhc3RQb3MgPCBpKSBvdXQgKz0gc3RyLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgIG91dCArPSBoZXhUYWJsZVtjXTtcbiAgICAgIH1cbiAgICAgIGlmICgrK2kgPT09IGxlbikgYnJlYWsgb3V0ZXI7XG4gICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIGlmIChsYXN0UG9zIDwgaSkgb3V0ICs9IHN0ci5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAvLyBNdWx0aS1ieXRlIGNoYXJhY3RlcnMgLi4uXG4gICAgaWYgKGMgPCAweDgwMCkge1xuICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgb3V0ICs9IGhleFRhYmxlWzB4YzAgfCBjID4+IDZdICsgaGV4VGFibGVbMHg4MCB8IGMgJiAweDNmXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgb3V0ICs9IGhleFRhYmxlWzB4ZTAgfCBjID4+IDEyXSArIGhleFRhYmxlWzB4ODAgfCBjID4+IDYgJiAweDNmXSArIGhleFRhYmxlWzB4ODAgfCBjICYgMHgzZl07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gU3Vycm9nYXRlIHBhaXJcbiAgICArK2k7XG4gICAgLy8gVGhpcyBicmFuY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiBiZWNhdXNlIGFsbCBVUkxTZWFyY2hQYXJhbXMgZW50cmllc1xuICAgIC8vIHNob3VsZCBhbHJlYWR5IGJlIGNvbnZlcnRlZCB0byBVU1ZTdHJpbmcuIEJ1dCwgaW5jbHVkZWQgZm9yXG4gICAgLy8gY29tcGxldGlvbidzIHNha2UgYW55d2F5LlxuICAgIGlmIChpID49IGxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJJIG1hbGZvcm1lZFwiKTtcbiAgICB9XG4gICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmO1xuICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4M2ZmKSA8PCAxMCB8IGMyKTtcbiAgICBvdXQgKz0gaGV4VGFibGVbMHhmMCB8IGMgPj4gMThdICsgaGV4VGFibGVbMHg4MCB8IGMgPj4gMTIgJiAweDNmXSArIGhleFRhYmxlWzB4ODAgfCBjID4+IDYgJiAweDNmXSArIGhleFRhYmxlWzB4ODAgfCBjICYgMHgzZl07XG4gIH1cbiAgaWYgKGxhc3RQb3MgPT09IDApIHJldHVybiBzdHI7XG4gIGlmIChsYXN0UG9zIDwgbGVuKSByZXR1cm4gb3V0ICsgc3RyLnNsaWNlKGxhc3RQb3MpO1xuICByZXR1cm4gb3V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVlcnlTdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   make: () => (/* binding */ make)\n/* harmony export */ });\n/* harmony import */ var _internal_router_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/router.js */ \"(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js\");\n/**\n * @since 1.0.0\n */\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nconst make = _internal_router_js__WEBPACK_IMPORTED_MODULE_0__.make;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyxhQUFhLHFEQUFhO0FBQ2pDIiwic291cmNlcyI6WyJEOlxcdGVtcFxcWW91VHViZVxcbm9kZV9tb2R1bGVzXFxmaW5kLW15LXdheS10c1xcZGlzdFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBzaW5jZSAxLjAuMFxuICovXG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tIFwiLi9pbnRlcm5hbC9yb3V0ZXIuanNcIjtcbi8qKlxuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgY29uc3RydWN0b3JzXG4gKi9cbmV4cG9ydCBjb25zdCBtYWtlID0gaW50ZXJuYWwubWFrZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/find-my-way-ts/dist/esm/internal/router.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   make: () => (/* binding */ make)\n/* harmony export */ });\n/* harmony import */ var _QueryString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../QueryString.js */ \"(rsc)/./node_modules/find-my-way-ts/dist/esm/QueryString.js\");\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//;\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/;\n/** @internal */\nconst make = (options = {}) => new RouterImpl(options);\nclass RouterImpl {\n  constructor(options = {}) {\n    this.options = {\n      ignoreTrailingSlash: true,\n      ignoreDuplicateSlashes: true,\n      caseSensitive: false,\n      maxParamLength: 100,\n      ...options\n    };\n  }\n  options;\n  routes = [];\n  trees = {};\n  on(method, path, handler) {\n    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);\n    if (optionalParamMatch && optionalParamMatch.index !== undefined) {\n      assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, \"Optional Parameter needs to be the last parameter of the path\");\n      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, \"$1$2\");\n      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, \"$2\");\n      this.on(method, pathFull, handler);\n      this.on(method, pathOptional, handler);\n      return;\n    }\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path);\n    }\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path);\n    }\n    const methods = typeof method === \"string\" ? [method] : method;\n    for (const method of methods) {\n      this._on(method, path, handler);\n    }\n  }\n  all(path, handler) {\n    this.on(httpMethods, path, handler);\n  }\n  _on(method, path, handler) {\n    if (this.trees[method] === undefined) {\n      this.trees[method] = new StaticNode(\"/\");\n    }\n    let pattern = path;\n    if (pattern === \"*\" && this.trees[method].prefix.length !== 0) {\n      const currentRoot = this.trees[method];\n      this.trees[method] = new StaticNode(\"\");\n      this.trees[method].staticChildren[\"/\"] = currentRoot;\n    }\n    let parentNodePathIndex = this.trees[method].prefix.length;\n    let currentNode = this.trees[method];\n    const params = [];\n    for (let i = 0; i <= pattern.length; i++) {\n      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {\n        // It's a double colon\n        i++;\n        continue;\n      }\n      const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;\n      const isWildcardNode = pattern.charCodeAt(i) === 42;\n      if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {\n        let staticNodePath = pattern.slice(parentNodePathIndex, i);\n        if (!this.options.caseSensitive) {\n          staticNodePath = staticNodePath.toLowerCase();\n        }\n        staticNodePath = staticNodePath.split(\"::\").join(\":\");\n        staticNodePath = staticNodePath.split(\"%\").join(\"%25\");\n        // add the static part of the route to the tree\n        currentNode = currentNode.createStaticChild(staticNodePath);\n      }\n      if (isParametricNode) {\n        let isRegexNode = false;\n        const regexps = [];\n        let lastParamStartIndex = i + 1;\n        for (let j = lastParamStartIndex;; j++) {\n          const charCode = pattern.charCodeAt(j);\n          const isRegexParam = charCode === 40;\n          const isStaticPart = charCode === 45 || charCode === 46;\n          const isEndOfNode = charCode === 47 || j === pattern.length;\n          if (isRegexParam || isStaticPart || isEndOfNode) {\n            const paramName = pattern.slice(lastParamStartIndex, j);\n            params.push(paramName);\n            isRegexNode = isRegexNode || isRegexParam || isStaticPart;\n            if (isRegexParam) {\n              const endOfRegexIndex = getClosingParenthensePosition(pattern, j);\n              const regexString = pattern.slice(j, endOfRegexIndex + 1);\n              regexps.push(trimRegExpStartAndEnd(regexString));\n              j = endOfRegexIndex + 1;\n            } else {\n              regexps.push(\"(.*?)\");\n            }\n            const staticPartStartIndex = j;\n            for (; j < pattern.length; j++) {\n              const charCode = pattern.charCodeAt(j);\n              if (charCode === 47) break;\n              if (charCode === 58) {\n                const nextCharCode = pattern.charCodeAt(j + 1);\n                if (nextCharCode === 58) j++;else break;\n              }\n            }\n            let staticPart = pattern.slice(staticPartStartIndex, j);\n            if (staticPart) {\n              staticPart = staticPart.split(\"::\").join(\":\");\n              staticPart = staticPart.split(\"%\").join(\"%25\");\n              regexps.push(escapeRegExp(staticPart));\n            }\n            lastParamStartIndex = j + 1;\n            if (isEndOfNode || pattern.charCodeAt(j) === 47 || j === pattern.length) {\n              const nodePattern = isRegexNode ? \"()\" + staticPart : staticPart;\n              const nodePath = pattern.slice(i, j);\n              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j);\n              i += nodePattern.length;\n              const regex = isRegexNode ? new RegExp(\"^\" + regexps.join(\"\") + \"$\") : undefined;\n              currentNode = currentNode.createParametricChild(regex, staticPart, nodePath);\n              parentNodePathIndex = i + 1;\n              break;\n            }\n          }\n        }\n      } else if (isWildcardNode) {\n        // add the wildcard parameter\n        params.push(\"*\");\n        currentNode = currentNode.createWildcardChild();\n        parentNodePathIndex = i + 1;\n        if (i !== pattern.length - 1) {\n          throw new Error(\"Wildcard must be the last character in the route\");\n        }\n      }\n    }\n    if (!this.options.caseSensitive) {\n      pattern = pattern.toLowerCase();\n    }\n    if (pattern === \"*\") {\n      pattern = \"/*\";\n    }\n    for (const existRoute of this.routes) {\n      if (existRoute.method === method && existRoute.pattern === pattern) {\n        throw new Error(`Method '${method}' already declared for route '${pattern}'`);\n      }\n    }\n    const route = {\n      method,\n      path,\n      pattern,\n      params,\n      handler\n    };\n    this.routes.push(route);\n    currentNode.addRoute(route);\n  }\n  has(method, path) {\n    const node = this.trees[method];\n    if (node === undefined) {\n      return false;\n    }\n    const staticNode = node.getStaticChild(path);\n    if (staticNode === undefined) {\n      return false;\n    }\n    return staticNode.isLeafNode;\n  }\n  find(method, path) {\n    let currentNode = this.trees[method];\n    if (currentNode === undefined) return undefined;\n    if (path.charCodeAt(0) !== 47) {\n      // 47 is '/'\n      path = path.replace(FULL_PATH_REGEXP, \"/\");\n    }\n    // This must be run before sanitizeUrl as the resulting function\n    // .sliceParameter must be constructed with same URL string used\n    // throughout the rest of this function.\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path);\n    }\n    let sanitizedUrl;\n    let querystring;\n    let shouldDecodeParam;\n    try {\n      sanitizedUrl = safeDecodeURI(path);\n      path = sanitizedUrl.path;\n      querystring = sanitizedUrl.querystring;\n      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;\n    } catch (error) {\n      return undefined;\n    }\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path);\n    }\n    const originPath = path;\n    if (this.options.caseSensitive === false) {\n      path = path.toLowerCase();\n    }\n    const maxParamLength = this.options.maxParamLength;\n    let pathIndex = currentNode.prefix.length;\n    const params = [];\n    const pathLen = path.length;\n    const brothersNodesStack = [];\n    while (true) {\n      if (pathIndex === pathLen && currentNode.isLeafNode) {\n        const handle = currentNode.handlerStorage?.find();\n        if (handle !== undefined) {\n          return {\n            handler: handle.handler,\n            params: handle.createParams(params),\n            searchParams: _QueryString_js__WEBPACK_IMPORTED_MODULE_0__.parse(querystring)\n          };\n        }\n      }\n      let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);\n      if (node === undefined) {\n        if (brothersNodesStack.length === 0) {\n          return undefined;\n        }\n        const brotherNodeState = brothersNodesStack.pop();\n        pathIndex = brotherNodeState.brotherPathIndex;\n        params.splice(brotherNodeState.paramsCount);\n        node = brotherNodeState.brotherNode;\n      }\n      currentNode = node;\n      // static route\n      if (currentNode._tag === \"StaticNode\") {\n        pathIndex += currentNode.prefix.length;\n        continue;\n      }\n      if (currentNode._tag === \"WildcardNode\") {\n        let param = originPath.slice(pathIndex);\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param);\n        }\n        params.push(param);\n        pathIndex = pathLen;\n        continue;\n      }\n      if (currentNode._tag === \"ParametricNode\") {\n        let paramEndIndex = originPath.indexOf(\"/\", pathIndex);\n        if (paramEndIndex === -1) {\n          paramEndIndex = pathLen;\n        }\n        let param = originPath.slice(pathIndex, paramEndIndex);\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param);\n        }\n        if (currentNode.regex !== undefined) {\n          const matchedParameters = currentNode.regex.exec(param);\n          if (matchedParameters === null) continue;\n          for (let i = 1; i < matchedParameters.length; i++) {\n            const matchedParam = matchedParameters[i];\n            if (matchedParam.length > maxParamLength) {\n              return undefined;\n            }\n            params.push(matchedParam);\n          }\n        } else {\n          if (param.length > maxParamLength) {\n            return undefined;\n          }\n          params.push(param);\n        }\n        pathIndex = paramEndIndex;\n      }\n    }\n  }\n}\nclass HandlerStorage {\n  handlers = [];\n  unconstrainedHandler;\n  find() {\n    return this.unconstrainedHandler;\n  }\n  add(route) {\n    const handler = {\n      params: route.params,\n      handler: route.handler,\n      createParams: compileCreateParams(route.params)\n    };\n    this.handlers.push(handler);\n    this.unconstrainedHandler = this.handlers[0];\n  }\n}\nclass NodeBase {\n  isLeafNode = false;\n  routes;\n  handlerStorage;\n  addRoute(route) {\n    if (this.routes === undefined) {\n      this.routes = [route];\n    } else {\n      this.routes.push(route);\n    }\n    if (this.handlerStorage === undefined) {\n      this.handlerStorage = new HandlerStorage();\n    }\n    this.isLeafNode = true;\n    this.handlerStorage.add(route);\n  }\n}\nclass ParentNode extends NodeBase {\n  staticChildren = {};\n  findStaticMatchingChild(path, pathIndex) {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)];\n    if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {\n      return undefined;\n    }\n    return staticChild;\n  }\n  getStaticChild(path, pathIndex = 0) {\n    if (path.length === pathIndex) {\n      return this;\n    }\n    const staticChild = this.findStaticMatchingChild(path, pathIndex);\n    if (staticChild === undefined) {\n      return undefined;\n    }\n    return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);\n  }\n  createStaticChild(path) {\n    if (path.length === 0) {\n      return this;\n    }\n    let staticChild = this.staticChildren[path.charAt(0)];\n    if (staticChild) {\n      let i = 1;\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i);\n          break;\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i));\n    }\n    const label = path.charAt(0);\n    this.staticChildren[label] = new StaticNode(path);\n    return this.staticChildren[label];\n  }\n}\nclass StaticNode extends ParentNode {\n  _tag = \"StaticNode\";\n  constructor(prefix) {\n    super();\n    this.setPrefix(prefix);\n  }\n  prefix;\n  matchPrefix;\n  parametricChildren = [];\n  wildcardChild;\n  setPrefix(prefix) {\n    this.prefix = prefix;\n    if (prefix.length === 1) {\n      this.matchPrefix = (_path, _pathIndex) => true;\n    } else {\n      const len = prefix.length;\n      this.matchPrefix = function (path, pathIndex) {\n        for (let i = 1; i < len; i++) {\n          if (path.charCodeAt(pathIndex + i) !== this.prefix.charCodeAt(i)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n  }\n  getParametricChild(regex) {\n    if (regex === undefined) {\n      return this.parametricChildren.find(child => child.isRegex === false);\n    }\n    const source = regex.source;\n    return this.parametricChildren.find(child => {\n      if (child.regex === undefined) {\n        return false;\n      }\n      return child.regex.source === source;\n    });\n  }\n  createParametricChild(regex, staticSuffix, nodePath) {\n    let child = this.getParametricChild(regex);\n    if (child !== undefined) {\n      child.nodePaths.add(nodePath);\n      return child;\n    }\n    child = new ParametricNode(regex, staticSuffix, nodePath);\n    this.parametricChildren.push(child);\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1;\n      if (!child2.isRegex) return -1;\n      if (child1.staticSuffix === undefined) return 1;\n      if (child2.staticSuffix === undefined) return -1;\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;\n      return 0;\n    });\n    return child;\n  }\n  createWildcardChild() {\n    if (this.wildcardChild === undefined) {\n      this.wildcardChild = new WildcardNode();\n    }\n    return this.wildcardChild;\n  }\n  split(parentNode, length) {\n    const parentPrefix = this.prefix.slice(0, length);\n    const childPrefix = this.prefix.slice(length);\n    this.setPrefix(childPrefix);\n    const staticNode = new StaticNode(parentPrefix);\n    staticNode.staticChildren[childPrefix.charAt(0)] = this;\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;\n    return staticNode;\n  }\n  getNextNode(path, pathIndex, nodeStack, paramsCount) {\n    let node = this.findStaticMatchingChild(path, pathIndex);\n    let parametricBrotherNodeIndex = 0;\n    if (node === undefined) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild;\n      }\n      node = this.parametricChildren[0];\n      parametricBrotherNodeIndex = 1;\n    }\n    if (this.wildcardChild !== undefined) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild\n      });\n    }\n    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i]\n      });\n    }\n    return node;\n  }\n}\nclass ParametricNode extends ParentNode {\n  regex;\n  staticSuffix;\n  _tag = \"ParametricNode\";\n  constructor(regex, staticSuffix, nodePath) {\n    super();\n    this.regex = regex;\n    this.staticSuffix = staticSuffix;\n    this.isRegex = !!regex;\n    this.nodePaths = new Set([nodePath]);\n  }\n  isRegex;\n  nodePaths;\n  getNextNode(path, pathIndex) {\n    return this.findStaticMatchingChild(path, pathIndex);\n  }\n}\nclass WildcardNode extends NodeBase {\n  _tag = \"WildcardNode\";\n  getNextNode(_path, _pathIndex, _nodeStack, _paramsCount) {\n    return undefined;\n  }\n}\nconst assert = (condition, message) => {\n  if (!condition) {\n    throw new Error(message);\n  }\n};\nfunction removeDuplicateSlashes(path) {\n  return path.replace(/\\/\\/+/g, \"/\");\n}\nfunction trimLastSlash(path) {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1);\n  }\n  return path;\n}\nfunction compileCreateParams(params) {\n  const len = params.length;\n  return function (paramsArray) {\n    const paramsObject = {};\n    for (let i = 0; i < len; i++) {\n      paramsObject[params[i]] = paramsArray[i];\n    }\n    return paramsObject;\n  };\n}\nfunction getClosingParenthensePosition(path, idx) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n  let parentheses = 1;\n  while (idx < path.length) {\n    idx++;\n    // ignore skipped chars\n    if (path[idx] === \"\\\\\") {\n      idx++;\n      continue;\n    }\n    if (path[idx] === \")\") {\n      parentheses--;\n    } else if (path[idx] === \"(\") {\n      parentheses++;\n    }\n    if (!parentheses) return idx;\n  }\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"');\n}\nfunction trimRegExpStartAndEnd(regexString) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2);\n  }\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);\n  }\n  return regexString;\n}\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar(highCharCode, lowCharCode) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return \"%\";\n    if (lowCharCode === 51) return \"#\";\n    if (lowCharCode === 52) return \"$\";\n    if (lowCharCode === 54) return \"&\";\n    if (lowCharCode === 66) return \"+\";\n    if (lowCharCode === 98) return \"+\";\n    if (lowCharCode === 67) return \",\";\n    if (lowCharCode === 99) return \",\";\n    if (lowCharCode === 70) return \"/\";\n    if (lowCharCode === 102) return \"/\";\n    return undefined;\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return \":\";\n    if (lowCharCode === 97) return \":\";\n    if (lowCharCode === 66) return \";\";\n    if (lowCharCode === 98) return \";\";\n    if (lowCharCode === 68) return \"=\";\n    if (lowCharCode === 100) return \"=\";\n    if (lowCharCode === 70) return \"?\";\n    if (lowCharCode === 102) return \"?\";\n    return undefined;\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return \"@\";\n  }\n  return undefined;\n}\nfunction safeDecodeURI(path) {\n  let shouldDecode = false;\n  let shouldDecodeParam = false;\n  let querystring = \"\";\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i);\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1);\n      const lowCharCode = path.charCodeAt(i + 2);\n      if (decodeComponentChar(highCharCode, lowCharCode) === undefined) {\n        shouldDecode = true;\n      } else {\n        shouldDecodeParam = true;\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true;\n          path = path.slice(0, i + 1) + \"25\" + path.slice(i + 1);\n          i += 2;\n        }\n        i += 2;\n      }\n      // Some systems do not follow RFC and separate the path and query\n      // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n      // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1);\n      path = path.slice(0, i);\n      break;\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path;\n  return {\n    path: decodedPath,\n    querystring,\n    shouldDecodeParam\n  };\n}\nfunction safeDecodeURIComponent(uriComponent) {\n  const startIndex = uriComponent.indexOf(\"%\");\n  if (startIndex === -1) return uriComponent;\n  let decoded = \"\";\n  let lastIndex = startIndex;\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1);\n      const lowCharCode = uriComponent.charCodeAt(i + 2);\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar;\n      lastIndex = i + 3;\n    }\n  }\n  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);\n}\nconst httpMethods = [\"ACL\", \"BIND\", \"CHECKOUT\", \"CONNECT\", \"COPY\", \"DELETE\", \"GET\", \"HEAD\", \"LINK\", \"LOCK\", \"M-SEARCH\", \"MERGE\", \"MKACTIVITY\", \"MKCALENDAR\", \"MKCOL\", \"MOVE\", \"NOTIFY\", \"OPTIONS\", \"PATCH\", \"POST\", \"PROPFIND\", \"PROPPATCH\", \"PURGE\", \"PUT\", \"REBIND\", \"REPORT\", \"SEARCH\", \"SOURCE\", \"SUBSCRIBE\", \"TRACE\", \"UNBIND\", \"UNLINK\", \"UNLOCK\", \"UNSUBSCRIBE\"];\n//# sourceMappingURL=router.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmluZC1teS13YXktdHMvZGlzdC9lc20vaW50ZXJuYWwvcm91dGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNPLDBCQUEwQjtBQUNqQztBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU8sZ0NBQWdDLFFBQVE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0RBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOEJBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxREFBcUQsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQ0FBa0M7QUFDM0QscUNBQXFDO0FBQ3JDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFx0ZW1wXFxZb3VUdWJlXFxub2RlX21vZHVsZXNcXGZpbmQtbXktd2F5LXRzXFxkaXN0XFxlc21cXGludGVybmFsXFxyb3V0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUVMgZnJvbSBcIi4uL1F1ZXJ5U3RyaW5nLmpzXCI7XG5jb25zdCBGVUxMX1BBVEhfUkVHRVhQID0gL15odHRwcz86XFwvXFwvLio/XFwvLztcbmNvbnN0IE9QVElPTkFMX1BBUkFNX1JFR0VYUCA9IC8oXFwvOlteLygpXSo/KVxcPyhcXC8/KS87XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWFrZSA9IChvcHRpb25zID0ge30pID0+IG5ldyBSb3V0ZXJJbXBsKG9wdGlvbnMpO1xuY2xhc3MgUm91dGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGlnbm9yZVRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVTbGFzaGVzOiB0cnVlLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICBtYXhQYXJhbUxlbmd0aDogMTAwLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG4gIH1cbiAgb3B0aW9ucztcbiAgcm91dGVzID0gW107XG4gIHRyZWVzID0ge307XG4gIG9uKG1ldGhvZCwgcGF0aCwgaGFuZGxlcikge1xuICAgIGNvbnN0IG9wdGlvbmFsUGFyYW1NYXRjaCA9IHBhdGgubWF0Y2goT1BUSU9OQUxfUEFSQU1fUkVHRVhQKTtcbiAgICBpZiAob3B0aW9uYWxQYXJhbU1hdGNoICYmIG9wdGlvbmFsUGFyYW1NYXRjaC5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhc3NlcnQocGF0aC5sZW5ndGggPT09IG9wdGlvbmFsUGFyYW1NYXRjaC5pbmRleCArIG9wdGlvbmFsUGFyYW1NYXRjaFswXS5sZW5ndGgsIFwiT3B0aW9uYWwgUGFyYW1ldGVyIG5lZWRzIHRvIGJlIHRoZSBsYXN0IHBhcmFtZXRlciBvZiB0aGUgcGF0aFwiKTtcbiAgICAgIGNvbnN0IHBhdGhGdWxsID0gcGF0aC5yZXBsYWNlKE9QVElPTkFMX1BBUkFNX1JFR0VYUCwgXCIkMSQyXCIpO1xuICAgICAgY29uc3QgcGF0aE9wdGlvbmFsID0gcGF0aC5yZXBsYWNlKE9QVElPTkFMX1BBUkFNX1JFR0VYUCwgXCIkMlwiKTtcbiAgICAgIHRoaXMub24obWV0aG9kLCBwYXRoRnVsbCwgaGFuZGxlcik7XG4gICAgICB0aGlzLm9uKG1ldGhvZCwgcGF0aE9wdGlvbmFsLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVTbGFzaGVzKSB7XG4gICAgICBwYXRoID0gcmVtb3ZlRHVwbGljYXRlU2xhc2hlcyhwYXRoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVUcmFpbGluZ1NsYXNoKSB7XG4gICAgICBwYXRoID0gdHJpbUxhc3RTbGFzaChwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kcyA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgPyBbbWV0aG9kXSA6IG1ldGhvZDtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XG4gICAgICB0aGlzLl9vbihtZXRob2QsIHBhdGgsIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuICBhbGwocGF0aCwgaGFuZGxlcikge1xuICAgIHRoaXMub24oaHR0cE1ldGhvZHMsIHBhdGgsIGhhbmRsZXIpO1xuICB9XG4gIF9vbihtZXRob2QsIHBhdGgsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy50cmVlc1ttZXRob2RdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudHJlZXNbbWV0aG9kXSA9IG5ldyBTdGF0aWNOb2RlKFwiL1wiKTtcbiAgICB9XG4gICAgbGV0IHBhdHRlcm4gPSBwYXRoO1xuICAgIGlmIChwYXR0ZXJuID09PSBcIipcIiAmJiB0aGlzLnRyZWVzW21ldGhvZF0ucHJlZml4Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgY3VycmVudFJvb3QgPSB0aGlzLnRyZWVzW21ldGhvZF07XG4gICAgICB0aGlzLnRyZWVzW21ldGhvZF0gPSBuZXcgU3RhdGljTm9kZShcIlwiKTtcbiAgICAgIHRoaXMudHJlZXNbbWV0aG9kXS5zdGF0aWNDaGlsZHJlbltcIi9cIl0gPSBjdXJyZW50Um9vdDtcbiAgICB9XG4gICAgbGV0IHBhcmVudE5vZGVQYXRoSW5kZXggPSB0aGlzLnRyZWVzW21ldGhvZF0ucHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnRyZWVzW21ldGhvZF07XG4gICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGF0dGVybi5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhdHRlcm4uY2hhckNvZGVBdChpKSA9PT0gNTggJiYgcGF0dGVybi5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gNTgpIHtcbiAgICAgICAgLy8gSXQncyBhIGRvdWJsZSBjb2xvblxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQYXJhbWV0cmljTm9kZSA9IHBhdHRlcm4uY2hhckNvZGVBdChpKSA9PT0gNTggJiYgcGF0dGVybi5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gNTg7XG4gICAgICBjb25zdCBpc1dpbGRjYXJkTm9kZSA9IHBhdHRlcm4uY2hhckNvZGVBdChpKSA9PT0gNDI7XG4gICAgICBpZiAoaXNQYXJhbWV0cmljTm9kZSB8fCBpc1dpbGRjYXJkTm9kZSB8fCBpID09PSBwYXR0ZXJuLmxlbmd0aCAmJiBpICE9PSBwYXJlbnROb2RlUGF0aEluZGV4KSB7XG4gICAgICAgIGxldCBzdGF0aWNOb2RlUGF0aCA9IHBhdHRlcm4uc2xpY2UocGFyZW50Tm9kZVBhdGhJbmRleCwgaSk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgICBzdGF0aWNOb2RlUGF0aCA9IHN0YXRpY05vZGVQYXRoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljTm9kZVBhdGggPSBzdGF0aWNOb2RlUGF0aC5zcGxpdChcIjo6XCIpLmpvaW4oXCI6XCIpO1xuICAgICAgICBzdGF0aWNOb2RlUGF0aCA9IHN0YXRpY05vZGVQYXRoLnNwbGl0KFwiJVwiKS5qb2luKFwiJTI1XCIpO1xuICAgICAgICAvLyBhZGQgdGhlIHN0YXRpYyBwYXJ0IG9mIHRoZSByb3V0ZSB0byB0aGUgdHJlZVxuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmNyZWF0ZVN0YXRpY0NoaWxkKHN0YXRpY05vZGVQYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1BhcmFtZXRyaWNOb2RlKSB7XG4gICAgICAgIGxldCBpc1JlZ2V4Tm9kZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZWdleHBzID0gW107XG4gICAgICAgIGxldCBsYXN0UGFyYW1TdGFydEluZGV4ID0gaSArIDE7XG4gICAgICAgIGZvciAobGV0IGogPSBsYXN0UGFyYW1TdGFydEluZGV4OzsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgY29uc3QgaXNSZWdleFBhcmFtID0gY2hhckNvZGUgPT09IDQwO1xuICAgICAgICAgIGNvbnN0IGlzU3RhdGljUGFydCA9IGNoYXJDb2RlID09PSA0NSB8fCBjaGFyQ29kZSA9PT0gNDY7XG4gICAgICAgICAgY29uc3QgaXNFbmRPZk5vZGUgPSBjaGFyQ29kZSA9PT0gNDcgfHwgaiA9PT0gcGF0dGVybi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGlzUmVnZXhQYXJhbSB8fCBpc1N0YXRpY1BhcnQgfHwgaXNFbmRPZk5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhdHRlcm4uc2xpY2UobGFzdFBhcmFtU3RhcnRJbmRleCwgaik7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICAgICAgaXNSZWdleE5vZGUgPSBpc1JlZ2V4Tm9kZSB8fCBpc1JlZ2V4UGFyYW0gfHwgaXNTdGF0aWNQYXJ0O1xuICAgICAgICAgICAgaWYgKGlzUmVnZXhQYXJhbSkge1xuICAgICAgICAgICAgICBjb25zdCBlbmRPZlJlZ2V4SW5kZXggPSBnZXRDbG9zaW5nUGFyZW50aGVuc2VQb3NpdGlvbihwYXR0ZXJuLCBqKTtcbiAgICAgICAgICAgICAgY29uc3QgcmVnZXhTdHJpbmcgPSBwYXR0ZXJuLnNsaWNlKGosIGVuZE9mUmVnZXhJbmRleCArIDEpO1xuICAgICAgICAgICAgICByZWdleHBzLnB1c2godHJpbVJlZ0V4cFN0YXJ0QW5kRW5kKHJlZ2V4U3RyaW5nKSk7XG4gICAgICAgICAgICAgIGogPSBlbmRPZlJlZ2V4SW5kZXggKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnZXhwcy5wdXNoKFwiKC4qPylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNQYXJ0U3RhcnRJbmRleCA9IGo7XG4gICAgICAgICAgICBmb3IgKDsgaiA8IHBhdHRlcm4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXR0ZXJuLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PT0gNDcpIGJyZWFrO1xuICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IDU4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gcGF0dGVybi5jaGFyQ29kZUF0KGogKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dENoYXJDb2RlID09PSA1OCkgaisrO2Vsc2UgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGF0aWNQYXJ0ID0gcGF0dGVybi5zbGljZShzdGF0aWNQYXJ0U3RhcnRJbmRleCwgaik7XG4gICAgICAgICAgICBpZiAoc3RhdGljUGFydCkge1xuICAgICAgICAgICAgICBzdGF0aWNQYXJ0ID0gc3RhdGljUGFydC5zcGxpdChcIjo6XCIpLmpvaW4oXCI6XCIpO1xuICAgICAgICAgICAgICBzdGF0aWNQYXJ0ID0gc3RhdGljUGFydC5zcGxpdChcIiVcIikuam9pbihcIiUyNVwiKTtcbiAgICAgICAgICAgICAgcmVnZXhwcy5wdXNoKGVzY2FwZVJlZ0V4cChzdGF0aWNQYXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0UGFyYW1TdGFydEluZGV4ID0gaiArIDE7XG4gICAgICAgICAgICBpZiAoaXNFbmRPZk5vZGUgfHwgcGF0dGVybi5jaGFyQ29kZUF0KGopID09PSA0NyB8fCBqID09PSBwYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlUGF0dGVybiA9IGlzUmVnZXhOb2RlID8gXCIoKVwiICsgc3RhdGljUGFydCA6IHN0YXRpY1BhcnQ7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGVQYXRoID0gcGF0dGVybi5zbGljZShpLCBqKTtcbiAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMCwgaSArIDEpICsgbm9kZVBhdHRlcm4gKyBwYXR0ZXJuLnNsaWNlKGopO1xuICAgICAgICAgICAgICBpICs9IG5vZGVQYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBpc1JlZ2V4Tm9kZSA/IG5ldyBSZWdFeHAoXCJeXCIgKyByZWdleHBzLmpvaW4oXCJcIikgKyBcIiRcIikgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuY3JlYXRlUGFyYW1ldHJpY0NoaWxkKHJlZ2V4LCBzdGF0aWNQYXJ0LCBub2RlUGF0aCk7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGVQYXRoSW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzV2lsZGNhcmROb2RlKSB7XG4gICAgICAgIC8vIGFkZCB0aGUgd2lsZGNhcmQgcGFyYW1ldGVyXG4gICAgICAgIHBhcmFtcy5wdXNoKFwiKlwiKTtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5jcmVhdGVXaWxkY2FyZENoaWxkKCk7XG4gICAgICAgIHBhcmVudE5vZGVQYXRoSW5kZXggPSBpICsgMTtcbiAgICAgICAgaWYgKGkgIT09IHBhdHRlcm4ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldpbGRjYXJkIG11c3QgYmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIHRoZSByb3V0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5jYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAocGF0dGVybiA9PT0gXCIqXCIpIHtcbiAgICAgIHBhdHRlcm4gPSBcIi8qXCI7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXhpc3RSb3V0ZSBvZiB0aGlzLnJvdXRlcykge1xuICAgICAgaWYgKGV4aXN0Um91dGUubWV0aG9kID09PSBtZXRob2QgJiYgZXhpc3RSb3V0ZS5wYXR0ZXJuID09PSBwYXR0ZXJuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWV0aG9kICcke21ldGhvZH0nIGFscmVhZHkgZGVjbGFyZWQgZm9yIHJvdXRlICcke3BhdHRlcm59J2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByb3V0ZSA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhdGgsXG4gICAgICBwYXR0ZXJuLFxuICAgICAgcGFyYW1zLFxuICAgICAgaGFuZGxlclxuICAgIH07XG4gICAgdGhpcy5yb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgY3VycmVudE5vZGUuYWRkUm91dGUocm91dGUpO1xuICB9XG4gIGhhcyhtZXRob2QsIHBhdGgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy50cmVlc1ttZXRob2RdO1xuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGljTm9kZSA9IG5vZGUuZ2V0U3RhdGljQ2hpbGQocGF0aCk7XG4gICAgaWYgKHN0YXRpY05vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGljTm9kZS5pc0xlYWZOb2RlO1xuICB9XG4gIGZpbmQobWV0aG9kLCBwYXRoKSB7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy50cmVlc1ttZXRob2RdO1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoMCkgIT09IDQ3KSB7XG4gICAgICAvLyA0NyBpcyAnLydcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoRlVMTF9QQVRIX1JFR0VYUCwgXCIvXCIpO1xuICAgIH1cbiAgICAvLyBUaGlzIG11c3QgYmUgcnVuIGJlZm9yZSBzYW5pdGl6ZVVybCBhcyB0aGUgcmVzdWx0aW5nIGZ1bmN0aW9uXG4gICAgLy8gLnNsaWNlUGFyYW1ldGVyIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBzYW1lIFVSTCBzdHJpbmcgdXNlZFxuICAgIC8vIHRocm91Z2hvdXQgdGhlIHJlc3Qgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVNsYXNoZXMpIHtcbiAgICAgIHBhdGggPSByZW1vdmVEdXBsaWNhdGVTbGFzaGVzKHBhdGgpO1xuICAgIH1cbiAgICBsZXQgc2FuaXRpemVkVXJsO1xuICAgIGxldCBxdWVyeXN0cmluZztcbiAgICBsZXQgc2hvdWxkRGVjb2RlUGFyYW07XG4gICAgdHJ5IHtcbiAgICAgIHNhbml0aXplZFVybCA9IHNhZmVEZWNvZGVVUkkocGF0aCk7XG4gICAgICBwYXRoID0gc2FuaXRpemVkVXJsLnBhdGg7XG4gICAgICBxdWVyeXN0cmluZyA9IHNhbml0aXplZFVybC5xdWVyeXN0cmluZztcbiAgICAgIHNob3VsZERlY29kZVBhcmFtID0gc2FuaXRpemVkVXJsLnNob3VsZERlY29kZVBhcmFtO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmlnbm9yZVRyYWlsaW5nU2xhc2gpIHtcbiAgICAgIHBhdGggPSB0cmltTGFzdFNsYXNoKHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBvcmlnaW5QYXRoID0gcGF0aDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNhc2VTZW5zaXRpdmUgPT09IGZhbHNlKSB7XG4gICAgICBwYXRoID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQYXJhbUxlbmd0aCA9IHRoaXMub3B0aW9ucy5tYXhQYXJhbUxlbmd0aDtcbiAgICBsZXQgcGF0aEluZGV4ID0gY3VycmVudE5vZGUucHJlZml4Lmxlbmd0aDtcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICBjb25zdCBwYXRoTGVuID0gcGF0aC5sZW5ndGg7XG4gICAgY29uc3QgYnJvdGhlcnNOb2Rlc1N0YWNrID0gW107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChwYXRoSW5kZXggPT09IHBhdGhMZW4gJiYgY3VycmVudE5vZGUuaXNMZWFmTm9kZSkge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBjdXJyZW50Tm9kZS5oYW5kbGVyU3RvcmFnZT8uZmluZCgpO1xuICAgICAgICBpZiAoaGFuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlLmhhbmRsZXIsXG4gICAgICAgICAgICBwYXJhbXM6IGhhbmRsZS5jcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtczogUVMucGFyc2UocXVlcnlzdHJpbmcpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5vZGUgPSBjdXJyZW50Tm9kZS5nZXROZXh0Tm9kZShwYXRoLCBwYXRoSW5kZXgsIGJyb3RoZXJzTm9kZXNTdGFjaywgcGFyYW1zLmxlbmd0aCk7XG4gICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChicm90aGVyc05vZGVzU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBicm90aGVyTm9kZVN0YXRlID0gYnJvdGhlcnNOb2Rlc1N0YWNrLnBvcCgpO1xuICAgICAgICBwYXRoSW5kZXggPSBicm90aGVyTm9kZVN0YXRlLmJyb3RoZXJQYXRoSW5kZXg7XG4gICAgICAgIHBhcmFtcy5zcGxpY2UoYnJvdGhlck5vZGVTdGF0ZS5wYXJhbXNDb3VudCk7XG4gICAgICAgIG5vZGUgPSBicm90aGVyTm9kZVN0YXRlLmJyb3RoZXJOb2RlO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgLy8gc3RhdGljIHJvdXRlXG4gICAgICBpZiAoY3VycmVudE5vZGUuX3RhZyA9PT0gXCJTdGF0aWNOb2RlXCIpIHtcbiAgICAgICAgcGF0aEluZGV4ICs9IGN1cnJlbnROb2RlLnByZWZpeC5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnROb2RlLl90YWcgPT09IFwiV2lsZGNhcmROb2RlXCIpIHtcbiAgICAgICAgbGV0IHBhcmFtID0gb3JpZ2luUGF0aC5zbGljZShwYXRoSW5kZXgpO1xuICAgICAgICBpZiAoc2hvdWxkRGVjb2RlUGFyYW0pIHtcbiAgICAgICAgICBwYXJhbSA9IHNhZmVEZWNvZGVVUklDb21wb25lbnQocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgcGF0aEluZGV4ID0gcGF0aExlbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudE5vZGUuX3RhZyA9PT0gXCJQYXJhbWV0cmljTm9kZVwiKSB7XG4gICAgICAgIGxldCBwYXJhbUVuZEluZGV4ID0gb3JpZ2luUGF0aC5pbmRleE9mKFwiL1wiLCBwYXRoSW5kZXgpO1xuICAgICAgICBpZiAocGFyYW1FbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBwYXJhbUVuZEluZGV4ID0gcGF0aExlbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW0gPSBvcmlnaW5QYXRoLnNsaWNlKHBhdGhJbmRleCwgcGFyYW1FbmRJbmRleCk7XG4gICAgICAgIGlmIChzaG91bGREZWNvZGVQYXJhbSkge1xuICAgICAgICAgIHBhcmFtID0gc2FmZURlY29kZVVSSUNvbXBvbmVudChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJlZ2V4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGVkUGFyYW1ldGVycyA9IGN1cnJlbnROb2RlLnJlZ2V4LmV4ZWMocGFyYW0pO1xuICAgICAgICAgIGlmIChtYXRjaGVkUGFyYW1ldGVycyA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaGVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZFBhcmFtID0gbWF0Y2hlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlZFBhcmFtLmxlbmd0aCA+IG1heFBhcmFtTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMucHVzaChtYXRjaGVkUGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGFyYW0ubGVuZ3RoID4gbWF4UGFyYW1MZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoSW5kZXggPSBwYXJhbUVuZEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgSGFuZGxlclN0b3JhZ2Uge1xuICBoYW5kbGVycyA9IFtdO1xuICB1bmNvbnN0cmFpbmVkSGFuZGxlcjtcbiAgZmluZCgpIHtcbiAgICByZXR1cm4gdGhpcy51bmNvbnN0cmFpbmVkSGFuZGxlcjtcbiAgfVxuICBhZGQocm91dGUpIHtcbiAgICBjb25zdCBoYW5kbGVyID0ge1xuICAgICAgcGFyYW1zOiByb3V0ZS5wYXJhbXMsXG4gICAgICBoYW5kbGVyOiByb3V0ZS5oYW5kbGVyLFxuICAgICAgY3JlYXRlUGFyYW1zOiBjb21waWxlQ3JlYXRlUGFyYW1zKHJvdXRlLnBhcmFtcylcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICB0aGlzLnVuY29uc3RyYWluZWRIYW5kbGVyID0gdGhpcy5oYW5kbGVyc1swXTtcbiAgfVxufVxuY2xhc3MgTm9kZUJhc2Uge1xuICBpc0xlYWZOb2RlID0gZmFsc2U7XG4gIHJvdXRlcztcbiAgaGFuZGxlclN0b3JhZ2U7XG4gIGFkZFJvdXRlKHJvdXRlKSB7XG4gICAgaWYgKHRoaXMucm91dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMucm91dGVzID0gW3JvdXRlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhbmRsZXJTdG9yYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaGFuZGxlclN0b3JhZ2UgPSBuZXcgSGFuZGxlclN0b3JhZ2UoKTtcbiAgICB9XG4gICAgdGhpcy5pc0xlYWZOb2RlID0gdHJ1ZTtcbiAgICB0aGlzLmhhbmRsZXJTdG9yYWdlLmFkZChyb3V0ZSk7XG4gIH1cbn1cbmNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gIHN0YXRpY0NoaWxkcmVuID0ge307XG4gIGZpbmRTdGF0aWNNYXRjaGluZ0NoaWxkKHBhdGgsIHBhdGhJbmRleCkge1xuICAgIGNvbnN0IHN0YXRpY0NoaWxkID0gdGhpcy5zdGF0aWNDaGlsZHJlbltwYXRoLmNoYXJBdChwYXRoSW5kZXgpXTtcbiAgICBpZiAoc3RhdGljQ2hpbGQgPT09IHVuZGVmaW5lZCB8fCAhc3RhdGljQ2hpbGQubWF0Y2hQcmVmaXgocGF0aCwgcGF0aEluZGV4KSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRpY0NoaWxkO1xuICB9XG4gIGdldFN0YXRpY0NoaWxkKHBhdGgsIHBhdGhJbmRleCA9IDApIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IHBhdGhJbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRpY0NoaWxkID0gdGhpcy5maW5kU3RhdGljTWF0Y2hpbmdDaGlsZChwYXRoLCBwYXRoSW5kZXgpO1xuICAgIGlmIChzdGF0aWNDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGljQ2hpbGQuZ2V0U3RhdGljQ2hpbGQocGF0aCwgcGF0aEluZGV4ICsgc3RhdGljQ2hpbGQucHJlZml4Lmxlbmd0aCk7XG4gIH1cbiAgY3JlYXRlU3RhdGljQ2hpbGQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxldCBzdGF0aWNDaGlsZCA9IHRoaXMuc3RhdGljQ2hpbGRyZW5bcGF0aC5jaGFyQXQoMCldO1xuICAgIGlmIChzdGF0aWNDaGlsZCkge1xuICAgICAgbGV0IGkgPSAxO1xuICAgICAgZm9yICg7IGkgPCBzdGF0aWNDaGlsZC5wcmVmaXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSAhPT0gc3RhdGljQ2hpbGQucHJlZml4LmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgICAgICBzdGF0aWNDaGlsZCA9IHN0YXRpY0NoaWxkLnNwbGl0KHRoaXMsIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGljQ2hpbGQuY3JlYXRlU3RhdGljQ2hpbGQocGF0aC5zbGljZShpKSk7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsID0gcGF0aC5jaGFyQXQoMCk7XG4gICAgdGhpcy5zdGF0aWNDaGlsZHJlbltsYWJlbF0gPSBuZXcgU3RhdGljTm9kZShwYXRoKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWNDaGlsZHJlbltsYWJlbF07XG4gIH1cbn1cbmNsYXNzIFN0YXRpY05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgX3RhZyA9IFwiU3RhdGljTm9kZVwiO1xuICBjb25zdHJ1Y3RvcihwcmVmaXgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0UHJlZml4KHByZWZpeCk7XG4gIH1cbiAgcHJlZml4O1xuICBtYXRjaFByZWZpeDtcbiAgcGFyYW1ldHJpY0NoaWxkcmVuID0gW107XG4gIHdpbGRjYXJkQ2hpbGQ7XG4gIHNldFByZWZpeChwcmVmaXgpIHtcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcbiAgICBpZiAocHJlZml4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5tYXRjaFByZWZpeCA9IChfcGF0aCwgX3BhdGhJbmRleCkgPT4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICAgIHRoaXMubWF0Y2hQcmVmaXggPSBmdW5jdGlvbiAocGF0aCwgcGF0aEluZGV4KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KHBhdGhJbmRleCArIGkpICE9PSB0aGlzLnByZWZpeC5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZ2V0UGFyYW1ldHJpY0NoaWxkKHJlZ2V4KSB7XG4gICAgaWYgKHJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbi5maW5kKGNoaWxkID0+IGNoaWxkLmlzUmVnZXggPT09IGZhbHNlKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gcmVnZXguc291cmNlO1xuICAgIHJldHVybiB0aGlzLnBhcmFtZXRyaWNDaGlsZHJlbi5maW5kKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC5yZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGlsZC5yZWdleC5zb3VyY2UgPT09IHNvdXJjZTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVQYXJhbWV0cmljQ2hpbGQocmVnZXgsIHN0YXRpY1N1ZmZpeCwgbm9kZVBhdGgpIHtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldFBhcmFtZXRyaWNDaGlsZChyZWdleCk7XG4gICAgaWYgKGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoaWxkLm5vZGVQYXRocy5hZGQobm9kZVBhdGgpO1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBjaGlsZCA9IG5ldyBQYXJhbWV0cmljTm9kZShyZWdleCwgc3RhdGljU3VmZml4LCBub2RlUGF0aCk7XG4gICAgdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW4uc29ydCgoY2hpbGQxLCBjaGlsZDIpID0+IHtcbiAgICAgIGlmICghY2hpbGQxLmlzUmVnZXgpIHJldHVybiAxO1xuICAgICAgaWYgKCFjaGlsZDIuaXNSZWdleCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGNoaWxkMS5zdGF0aWNTdWZmaXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgICBpZiAoY2hpbGQyLnN0YXRpY1N1ZmZpeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICBpZiAoY2hpbGQyLnN0YXRpY1N1ZmZpeC5lbmRzV2l0aChjaGlsZDEuc3RhdGljU3VmZml4KSkgcmV0dXJuIDE7XG4gICAgICBpZiAoY2hpbGQxLnN0YXRpY1N1ZmZpeC5lbmRzV2l0aChjaGlsZDIuc3RhdGljU3VmZml4KSkgcmV0dXJuIC0xO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIGNyZWF0ZVdpbGRjYXJkQ2hpbGQoKSB7XG4gICAgaWYgKHRoaXMud2lsZGNhcmRDaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLndpbGRjYXJkQ2hpbGQgPSBuZXcgV2lsZGNhcmROb2RlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndpbGRjYXJkQ2hpbGQ7XG4gIH1cbiAgc3BsaXQocGFyZW50Tm9kZSwgbGVuZ3RoKSB7XG4gICAgY29uc3QgcGFyZW50UHJlZml4ID0gdGhpcy5wcmVmaXguc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaGlsZFByZWZpeCA9IHRoaXMucHJlZml4LnNsaWNlKGxlbmd0aCk7XG4gICAgdGhpcy5zZXRQcmVmaXgoY2hpbGRQcmVmaXgpO1xuICAgIGNvbnN0IHN0YXRpY05vZGUgPSBuZXcgU3RhdGljTm9kZShwYXJlbnRQcmVmaXgpO1xuICAgIHN0YXRpY05vZGUuc3RhdGljQ2hpbGRyZW5bY2hpbGRQcmVmaXguY2hhckF0KDApXSA9IHRoaXM7XG4gICAgcGFyZW50Tm9kZS5zdGF0aWNDaGlsZHJlbltwYXJlbnRQcmVmaXguY2hhckF0KDApXSA9IHN0YXRpY05vZGU7XG4gICAgcmV0dXJuIHN0YXRpY05vZGU7XG4gIH1cbiAgZ2V0TmV4dE5vZGUocGF0aCwgcGF0aEluZGV4LCBub2RlU3RhY2ssIHBhcmFtc0NvdW50KSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmZpbmRTdGF0aWNNYXRjaGluZ0NoaWxkKHBhdGgsIHBhdGhJbmRleCk7XG4gICAgbGV0IHBhcmFtZXRyaWNCcm90aGVyTm9kZUluZGV4ID0gMDtcbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5wYXJhbWV0cmljQ2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbGRjYXJkQ2hpbGQ7XG4gICAgICB9XG4gICAgICBub2RlID0gdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW5bMF07XG4gICAgICBwYXJhbWV0cmljQnJvdGhlck5vZGVJbmRleCA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLndpbGRjYXJkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZVN0YWNrLnB1c2goe1xuICAgICAgICBwYXJhbXNDb3VudCxcbiAgICAgICAgYnJvdGhlclBhdGhJbmRleDogcGF0aEluZGV4LFxuICAgICAgICBicm90aGVyTm9kZTogdGhpcy53aWxkY2FyZENoaWxkXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucGFyYW1ldHJpY0NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gcGFyYW1ldHJpY0Jyb3RoZXJOb2RlSW5kZXg7IGktLSkge1xuICAgICAgbm9kZVN0YWNrLnB1c2goe1xuICAgICAgICBwYXJhbXNDb3VudCxcbiAgICAgICAgYnJvdGhlclBhdGhJbmRleDogcGF0aEluZGV4LFxuICAgICAgICBicm90aGVyTm9kZTogdGhpcy5wYXJhbWV0cmljQ2hpbGRyZW5baV1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuY2xhc3MgUGFyYW1ldHJpY05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgcmVnZXg7XG4gIHN0YXRpY1N1ZmZpeDtcbiAgX3RhZyA9IFwiUGFyYW1ldHJpY05vZGVcIjtcbiAgY29uc3RydWN0b3IocmVnZXgsIHN0YXRpY1N1ZmZpeCwgbm9kZVBhdGgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVnZXggPSByZWdleDtcbiAgICB0aGlzLnN0YXRpY1N1ZmZpeCA9IHN0YXRpY1N1ZmZpeDtcbiAgICB0aGlzLmlzUmVnZXggPSAhIXJlZ2V4O1xuICAgIHRoaXMubm9kZVBhdGhzID0gbmV3IFNldChbbm9kZVBhdGhdKTtcbiAgfVxuICBpc1JlZ2V4O1xuICBub2RlUGF0aHM7XG4gIGdldE5leHROb2RlKHBhdGgsIHBhdGhJbmRleCkge1xuICAgIHJldHVybiB0aGlzLmZpbmRTdGF0aWNNYXRjaGluZ0NoaWxkKHBhdGgsIHBhdGhJbmRleCk7XG4gIH1cbn1cbmNsYXNzIFdpbGRjYXJkTm9kZSBleHRlbmRzIE5vZGVCYXNlIHtcbiAgX3RhZyA9IFwiV2lsZGNhcmROb2RlXCI7XG4gIGdldE5leHROb2RlKF9wYXRoLCBfcGF0aEluZGV4LCBfbm9kZVN0YWNrLCBfcGFyYW1zQ291bnQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5jb25zdCBhc3NlcnQgPSAoY29uZGl0aW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlU2xhc2hlcyhwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLysvZywgXCIvXCIpO1xufVxuZnVuY3Rpb24gdHJpbUxhc3RTbGFzaChwYXRoKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDEgJiYgcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3KSB7XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gY29tcGlsZUNyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgY29uc3QgbGVuID0gcGFyYW1zLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwYXJhbXNBcnJheSkge1xuICAgIGNvbnN0IHBhcmFtc09iamVjdCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHBhcmFtc09iamVjdFtwYXJhbXNbaV1dID0gcGFyYW1zQXJyYXlbaV07XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXNPYmplY3Q7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbG9zaW5nUGFyZW50aGVuc2VQb3NpdGlvbihwYXRoLCBpZHgpIHtcbiAgLy8gYHBhdGguaW5kZXhPZigpYCB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIGZpcnN0IHBvc2l0aW9uIG9mIHRoZSBjbG9zaW5nIHBhcmVudGhlc2UsXG4gIC8vIGJ1dCBpdCdzIGluZWZmaWNpZW50IGZvciBncm91cGVkIG9yIHdyb25nIHJlZ2V4cCBleHByZXNzaW9ucy5cbiAgLy8gc2VlIGlzc3VlcyAjNjIgYW5kICM2MyBmb3IgbW9yZSBpbmZvXG4gIGxldCBwYXJlbnRoZXNlcyA9IDE7XG4gIHdoaWxlIChpZHggPCBwYXRoLmxlbmd0aCkge1xuICAgIGlkeCsrO1xuICAgIC8vIGlnbm9yZSBza2lwcGVkIGNoYXJzXG4gICAgaWYgKHBhdGhbaWR4XSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIGlkeCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwYXRoW2lkeF0gPT09IFwiKVwiKSB7XG4gICAgICBwYXJlbnRoZXNlcy0tO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpZHhdID09PSBcIihcIikge1xuICAgICAgcGFyZW50aGVzZXMrKztcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRoZXNlcykgcmV0dXJuIGlkeDtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHJlZ2V4cCBleHByZXNzaW9uIGluIFwiJyArIHBhdGggKyAnXCInKTtcbn1cbmZ1bmN0aW9uIHRyaW1SZWdFeHBTdGFydEFuZEVuZChyZWdleFN0cmluZykge1xuICAvLyByZW1vdmVzIGNoYXJzIHRoYXQgbWFya3Mgc3RhcnQgXCJeXCIgYW5kIGVuZCBcIiRcIiBvZiByZWdleHBcbiAgaWYgKHJlZ2V4U3RyaW5nLmNoYXJDb2RlQXQoMSkgPT09IDk0KSB7XG4gICAgcmVnZXhTdHJpbmcgPSByZWdleFN0cmluZy5zbGljZSgwLCAxKSArIHJlZ2V4U3RyaW5nLnNsaWNlKDIpO1xuICB9XG4gIGlmIChyZWdleFN0cmluZy5jaGFyQ29kZUF0KHJlZ2V4U3RyaW5nLmxlbmd0aCAtIDIpID09PSAzNikge1xuICAgIHJlZ2V4U3RyaW5nID0gcmVnZXhTdHJpbmcuc2xpY2UoMCwgcmVnZXhTdHJpbmcubGVuZ3RoIC0gMikgKyByZWdleFN0cmluZy5zbGljZShyZWdleFN0cmluZy5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gcmVnZXhTdHJpbmc7XG59XG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuLy8gSXQgbXVzdCBzcG90IGFsbCB0aGUgY2hhcnMgd2hlcmUgZGVjb2RlVVJJQ29tcG9uZW50KHgpICE9PSBkZWNvZGVVUkkoeClcbi8vIFRoZSBjaGFycyBhcmU6ICMgJCAmICsgLCAvIDogOyA9ID8gQFxuZnVuY3Rpb24gZGVjb2RlQ29tcG9uZW50Q2hhcihoaWdoQ2hhckNvZGUsIGxvd0NoYXJDb2RlKSB7XG4gIGlmIChoaWdoQ2hhckNvZGUgPT09IDUwKSB7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA1MykgcmV0dXJuIFwiJVwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNTEpIHJldHVybiBcIiNcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDUyKSByZXR1cm4gXCIkXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA1NCkgcmV0dXJuIFwiJlwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNjYpIHJldHVybiBcIitcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDk4KSByZXR1cm4gXCIrXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA2NykgcmV0dXJuIFwiLFwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gOTkpIHJldHVybiBcIixcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDcwKSByZXR1cm4gXCIvXCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSAxMDIpIHJldHVybiBcIi9cIjtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChoaWdoQ2hhckNvZGUgPT09IDUxKSB7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA2NSkgcmV0dXJuIFwiOlwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gOTcpIHJldHVybiBcIjpcIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDY2KSByZXR1cm4gXCI7XCI7XG4gICAgaWYgKGxvd0NoYXJDb2RlID09PSA5OCkgcmV0dXJuIFwiO1wiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNjgpIHJldHVybiBcIj1cIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDEwMCkgcmV0dXJuIFwiPVwiO1xuICAgIGlmIChsb3dDaGFyQ29kZSA9PT0gNzApIHJldHVybiBcIj9cIjtcbiAgICBpZiAobG93Q2hhckNvZGUgPT09IDEwMikgcmV0dXJuIFwiP1wiO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGhpZ2hDaGFyQ29kZSA9PT0gNTIgJiYgbG93Q2hhckNvZGUgPT09IDQ4KSB7XG4gICAgcmV0dXJuIFwiQFwiO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzYWZlRGVjb2RlVVJJKHBhdGgpIHtcbiAgbGV0IHNob3VsZERlY29kZSA9IGZhbHNlO1xuICBsZXQgc2hvdWxkRGVjb2RlUGFyYW0gPSBmYWxzZTtcbiAgbGV0IHF1ZXJ5c3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhckNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXJDb2RlID09PSAzNykge1xuICAgICAgY29uc3QgaGlnaENoYXJDb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGNvbnN0IGxvd0NoYXJDb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkgKyAyKTtcbiAgICAgIGlmIChkZWNvZGVDb21wb25lbnRDaGFyKGhpZ2hDaGFyQ29kZSwgbG93Q2hhckNvZGUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNob3VsZERlY29kZVBhcmFtID0gdHJ1ZTtcbiAgICAgICAgLy8gJTI1IC0gZW5jb2RlZCAlIGNoYXIuIFdlIG5lZWQgdG8gZW5jb2RlIG9uZSBtb3JlIHRpbWUgdG8gcHJldmVudCBkb3VibGUgZGVjb2RpbmdcbiAgICAgICAgaWYgKGhpZ2hDaGFyQ29kZSA9PT0gNTAgJiYgbG93Q2hhckNvZGUgPT09IDUzKSB7XG4gICAgICAgICAgc2hvdWxkRGVjb2RlID0gdHJ1ZTtcbiAgICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBpICsgMSkgKyBcIjI1XCIgKyBwYXRoLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAyO1xuICAgICAgfVxuICAgICAgLy8gU29tZSBzeXN0ZW1zIGRvIG5vdCBmb2xsb3cgUkZDIGFuZCBzZXBhcmF0ZSB0aGUgcGF0aCBhbmQgcXVlcnlcbiAgICAgIC8vIHN0cmluZyB3aXRoIGEgYDtgIGNoYXJhY3RlciAoY29kZSA1OSksIGUuZy4gYC9mb287anNlc3Npb25pZD0xMjM0NTZgLlxuICAgICAgLy8gVGh1cywgd2UgbmVlZCB0byBzcGxpdCBvbiBgO2AgYXMgd2VsbCBhcyBgP2AgYW5kIGAjYC5cbiAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09PSA2MyB8fCBjaGFyQ29kZSA9PT0gNTkgfHwgY2hhckNvZGUgPT09IDM1KSB7XG4gICAgICBxdWVyeXN0cmluZyA9IHBhdGguc2xpY2UoaSArIDEpO1xuICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjb2RlZFBhdGggPSBzaG91bGREZWNvZGUgPyBkZWNvZGVVUkkocGF0aCkgOiBwYXRoO1xuICByZXR1cm4ge1xuICAgIHBhdGg6IGRlY29kZWRQYXRoLFxuICAgIHF1ZXJ5c3RyaW5nLFxuICAgIHNob3VsZERlY29kZVBhcmFtXG4gIH07XG59XG5mdW5jdGlvbiBzYWZlRGVjb2RlVVJJQ29tcG9uZW50KHVyaUNvbXBvbmVudCkge1xuICBjb25zdCBzdGFydEluZGV4ID0gdXJpQ29tcG9uZW50LmluZGV4T2YoXCIlXCIpO1xuICBpZiAoc3RhcnRJbmRleCA9PT0gLTEpIHJldHVybiB1cmlDb21wb25lbnQ7XG4gIGxldCBkZWNvZGVkID0gXCJcIjtcbiAgbGV0IGxhc3RJbmRleCA9IHN0YXJ0SW5kZXg7XG4gIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgdXJpQ29tcG9uZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHVyaUNvbXBvbmVudC5jaGFyQ29kZUF0KGkpID09PSAzNykge1xuICAgICAgY29uc3QgaGlnaENoYXJDb2RlID0gdXJpQ29tcG9uZW50LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgY29uc3QgbG93Q2hhckNvZGUgPSB1cmlDb21wb25lbnQuY2hhckNvZGVBdChpICsgMik7XG4gICAgICBjb25zdCBkZWNvZGVkQ2hhciA9IGRlY29kZUNvbXBvbmVudENoYXIoaGlnaENoYXJDb2RlLCBsb3dDaGFyQ29kZSk7XG4gICAgICBkZWNvZGVkICs9IHVyaUNvbXBvbmVudC5zbGljZShsYXN0SW5kZXgsIGkpICsgZGVjb2RlZENoYXI7XG4gICAgICBsYXN0SW5kZXggPSBpICsgMztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVyaUNvbXBvbmVudC5zbGljZSgwLCBzdGFydEluZGV4KSArIGRlY29kZWQgKyB1cmlDb21wb25lbnQuc2xpY2UobGFzdEluZGV4KTtcbn1cbmNvbnN0IGh0dHBNZXRob2RzID0gW1wiQUNMXCIsIFwiQklORFwiLCBcIkNIRUNLT1VUXCIsIFwiQ09OTkVDVFwiLCBcIkNPUFlcIiwgXCJERUxFVEVcIiwgXCJHRVRcIiwgXCJIRUFEXCIsIFwiTElOS1wiLCBcIkxPQ0tcIiwgXCJNLVNFQVJDSFwiLCBcIk1FUkdFXCIsIFwiTUtBQ1RJVklUWVwiLCBcIk1LQ0FMRU5EQVJcIiwgXCJNS0NPTFwiLCBcIk1PVkVcIiwgXCJOT1RJRllcIiwgXCJPUFRJT05TXCIsIFwiUEFUQ0hcIiwgXCJQT1NUXCIsIFwiUFJPUEZJTkRcIiwgXCJQUk9QUEFUQ0hcIiwgXCJQVVJHRVwiLCBcIlBVVFwiLCBcIlJFQklORFwiLCBcIlJFUE9SVFwiLCBcIlNFQVJDSFwiLCBcIlNPVVJDRVwiLCBcIlNVQlNDUklCRVwiLCBcIlRSQUNFXCIsIFwiVU5CSU5EXCIsIFwiVU5MSU5LXCIsIFwiVU5MT0NLXCIsIFwiVU5TVUJTQ1JJQkVcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/find-my-way-ts/dist/esm/internal/router.js\n");

/***/ })

};
;